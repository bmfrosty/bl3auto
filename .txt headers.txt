[1mdiff --git a/.gitignore b/.gitignore[m
[1mindex 58c5616..16daa54 100644[m
[1m--- a/.gitignore[m
[1m+++ b/.gitignore[m
[36m@@ -21,3 +21,8 @@[m [mdist[m
 [m
 # ignore cosign private key[m
 cosign.key[m
[32m+[m
[32m+[m[32m# ignore test.sh and test files[m
[32m+[m[32mtest.sh[m
[32m+[m[32mcookies.txt[m
[32m+[m[32mheaders.txt[m
[1mdiff --git a/client.go b/client.go[m
[1mindex 64749df..cb0f09f 100644[m
[1m--- a/client.go[m
[1m+++ b/client.go[m
[36m@@ -4,9 +4,13 @@[m [mimport ([m
 	"bytes"[m
 	"encoding/json"[m
 	"errors"[m
[32m+[m	[32m"fmt"[m
 	"io"[m
 	"net/http"[m
 	"net/http/cookiejar"[m
[32m+[m	[32m"net/url"[m
[32m+[m	[32m"os"[m
[32m+[m	[32m"time"[m
 [m
 	"github.com/PuerkitoBio/goquery"[m
 	"github.com/thedevsaddam/gojsonq/v2"[m
[36m@@ -30,9 +34,19 @@[m [mfunc NewHttpClient() (*HttpClient, error) {[m
 	return &HttpClient{[m
 		http.Client{[m
 			Jar: jar,[m
[32m+[m			[32mCheckRedirect: func(req *http.Request, via []*http.Request) error {[m
[32m+[m				[32m// Don't follow redirects automatically - we want to handle them manually[m
[32m+[m				[32mreturn http.ErrUseLastResponse[m
[32m+[m			[32m},[m
 		},[m
 		http.Header{[m
[31m-			"User-Agent": []string{"BL3 Auto SHiFT"},[m
[32m+[m			[32m"User-Agent":      []string{"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/119.0"},[m
[32m+[m			[32m"Accept":          []string{"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8"},[m
[32m+[m			[32m"Accept-Language": []string{"en-US,en;q=0.5"},[m
[32m+[m			[32m"Accept-Encoding": []string{"gzip, deflate, br"},[m
[32m+[m			[32m"DNT":             []string{"1"},[m
[32m+[m			[32m"Connection":      []string{"keep-alive"},[m
[32m+[m			[32m"Upgrade-Insecure-Requests": []string{"1"},[m
 		},[m
 	}, nil[m
 }[m
[36m@@ -64,9 +78,15 @@[m [mfunc (response *HttpResponse) BodyAsJson() (*gojsonq.JSONQ, error) {[m
 }[m
 [m
 func getResponse(res *http.Response, err error) (*HttpResponse, error) {[m
[32m+[m	[32mif err != nil {[m
[32m+[m		[32mreturn nil, err[m
[32m+[m	[32m}[m
[32m+[m	[32mif res == nil {[m
[32m+[m		[32mreturn nil, errors.New("received nil response")[m
[32m+[m	[32m}[m
 	return &HttpResponse{[m
 		*res,[m
[31m-	}, err[m
[32m+[m	[32m}, nil[m
 }[m
 [m
 func (client *HttpClient) SetDefaultHeader(k, v string) {[m
[36m@@ -126,17 +146,17 @@[m [mfunc NewBl3Client() (*Bl3Client, error) {[m
 		return nil, errors.New("failed to start client")[m
 	}[m
 [m
[31m-	res, err := client.Get("https://raw.githubusercontent.com/jauderho/bl3auto/main/config.json")[m
[32m+[m	[32m// Load config from local file[m
[32m+[m	[32mconfigBytes, err := os.ReadFile("config.json")[m
 	if err != nil {[m
[31m-		return nil, errors.New("failed to get config")[m
[32m+[m		[32mreturn nil, errors.New("failed to read local config.json: " + err.Error())[m
 	}[m
 [m
[31m-	configJson, err := res.BodyAsJson()[m
[32m+[m	[32mconfig := Bl3Config{}[m
[32m+[m	[32merr = json.Unmarshal(configBytes, &config)[m
 	if err != nil {[m
[31m-		return nil, errors.New("failed to get config")[m
[32m+[m		[32mreturn nil, errors.New("failed to parse config.json: " + err.Error())[m
 	}[m
[31m-	config := Bl3Config{}[m
[31m-	configJson.Out(&config)[m
 [m
 	for header, value := range config.RequestHeaders {[m
 		client.SetDefaultHeader(header, value)[m
[36m@@ -149,31 +169,141 @@[m [mfunc NewBl3Client() (*Bl3Client, error) {[m
 }[m
 [m
 func (client *Bl3Client) Login(username string, password string) error {[m
[31m-	data := map[string]string{[m
[31m-		"username": username,[m
[31m-		"password": password,[m
[32m+[m	[32m// First, get the login page to extract CSRF token[m
[32m+[m	[32mhomeRes, err := client.Get("https://shift.gearboxsoftware.com/home")[m
[32m+[m	[32mif err != nil {[m
[32m+[m		[32mreturn errors.New("failed to get login page")[m
 	}[m
[32m+[m	[32mdefer homeRes.Body.Close()[m
 [m
[31m-	loginRes, err := client.PostJson(client.Config.LoginUrl, data)[m
[32m+[m	[32m// Parse the HTML to extract CSRF token from the hidden form field[m
[32m+[m	[32mdoc, err := homeRes.BodyAsHtmlDoc()[m
 	if err != nil {[m
[31m-		return errors.New("failed to submit login credentials")[m
[32m+[m		[32mreturn errors.New("failed to parse login page")[m
 	}[m
[31m-	defer loginRes.Body.Close()[m
 [m
[31m-	if loginRes.StatusCode != 200 {[m
[31m-		return errors.New("failed to login")[m
[32m+[m	[32m// Get the authenticity token from the hidden form input (not the meta tag)[m
[32m+[m	[32mcsrfToken, exists := doc.Find("input[name='authenticity_token']").Attr("value")[m
[32m+[m	[32mif !exists {[m
[32m+[m		[32mreturn errors.New("failed to find authenticity token in form")[m
 	}[m
 [m
[31m-	/* if loginRes.Header.Get(client.Config.LoginRedirectHeader) == "" {[m
[31m-		return errors.New("Failed to start session")[m
[32m+[m	[32m// Add a small delay to mimic human behavior[m
[32m+[m	[32mtime.Sleep(1 * time.Second)[m
[32m+[m
[32m+[m	[32m// Prepare form data using proper URL encoding[m
[32m+[m	[32mformValues := url.Values{}[m
[32m+[m	[32mformValues.Set("utf8", "âœ“")[m
[32m+[m	[32mformValues.Set("authenticity_token", csrfToken)[m
[32m+[m	[32mformValues.Set("user[email]", username)[m
[32m+[m	[32mformValues.Set("user[password]", password)[m
[32m+[m	[32mformValues.Set("commit", "SIGN IN")[m
[32m+[m[41m	[m
[32m+[m	[32mformData := formValues.Encode()[m
[32m+[m
[32m+[m	[32m// Create the POST request with proper headers[m
[32m+[m	[32mreq, err := http.NewRequest("POST", client.Config.LoginUrl, bytes.NewBufferString(formData))[m
[32m+[m	[32mif err != nil {[m
[32m+[m		[32mreturn errors.New("failed to create login request: " + err.Error())[m
 	}[m
[31m-[m
[31m-	sessionRes, err := client.Get(loginRes.Header.Get(client.Config.LoginRedirectHeader))[m
[32m+[m[41m	[m
[32m+[m	[32m// Set required headers for form submission[m
[32m+[m	[32mreq.Header.Set("Content-Type", "application/x-www-form-urlencoded")[m
[32m+[m	[32mreq.Header.Set("Referer", "https://shift.gearboxsoftware.com/home")[m
[32m+[m[41m	[m
[32m+[m	[32mloginRes, err := client.Do(req)[m
 	if err != nil {[m
[31m-		return errors.New("Failed to get session")[m
[32m+[m		[32mreturn errors.New("failed to submit login credentials: " + err.Error())[m
[32m+[m	[32m}[m
[32m+[m	[32mdefer loginRes.Body.Close()[m
[32m+[m
[32m+[m	[32m// Check for successful login (should be a redirect)[m
[32m+[m	[32mif loginRes.StatusCode == 503 {[m
[32m+[m		[32mreturn errors.New("SHiFT login service is temporarily unavailable (503). This may be due to rate limiting, maintenance, or the service being overloaded. Please try again later.")[m
[32m+[m	[32m}[m
[32m+[m[41m	[m
[32m+[m	[32m// Check for successful login - should be 302 redirect[m
[32m+[m	[32mif loginRes.StatusCode == 302 {[m
[32m+[m		[32mlocation := loginRes.Header.Get("Location")[m
[32m+[m[41m		[m
[32m+[m		[32m// Check if this is a failed login redirect (back to home with redirect_to=false)[m
[32m+[m		[32mif bytes.Contains([]byte(location), []byte("home?redirect_to=false")) {[m
[32m+[m			[32mreturn errors.New("login failed - invalid credentials (redirected back to login page)")[m
[32m+[m		[32m}[m
[32m+[m[41m		[m
[32m+[m		[32m// If it's a redirect to somewhere else, it's likely successful[m
[32m+[m		[32mif location != "" {[m
[32m+[m			[32m// Extract session cookie from response[m
[32m+[m			[32mcookies := loginRes.Header.Values("Set-Cookie")[m
[32m+[m			[32mfor _, cookie := range cookies {[m
[32m+[m				[32mif len(cookie) >= 12 && cookie[:12] == "_session_id=" {[m
[32m+[m					[32m// Extract just the session cookie part[m
[32m+[m					[32msessionCookie := cookie[m
[32m+[m					[32mif idx := bytes.IndexByte([]byte(cookie), ';'); idx != -1 {[m
[32m+[m						[32msessionCookie = cookie[:idx][m
[32m+[m					[32m}[m
[32m+[m					[32mclient.SetDefaultHeader("Cookie", sessionCookie)[m
[32m+[m					[32mreturn nil[m
[32m+[m				[32m}[m
[32m+[m			[32m}[m
[32m+[m			[32m// Even if no session cookie found, the redirect might indicate success[m
[32m+[m			[32mreturn nil[m
[32m+[m		[32m}[m
[32m+[m	[32m}[m
[32m+[m[41m	[m
[32m+[m	[32mif loginRes.StatusCode != 302 && loginRes.StatusCode != 200 {[m
[32m+[m		[32mreturn errors.New("unexpected login response status: " + fmt.Sprintf("%d", loginRes.StatusCode))[m
[32m+[m	[32m}[m
[32m+[m[41m	[m
[32m+[m	[32mif loginRes.StatusCode != 302 {[m
[32m+[m		[32m// Read the response body to get more details about the error[m
[32m+[m		[32mbodyBytes, _ := io.ReadAll(loginRes.Body)[m
[32m+[m		[32mbodyStr := string(bodyBytes)[m
[32m+[m[41m		[m
[32m+[m		[32m// Look for specific error messages in the response[m
[32m+[m		[32mif bytes.Contains(bodyBytes, []byte("Invalid email or password")) ||[m[41m [m
[32m+[m		[32m   bytes.Contains(bodyBytes, []byte("invalid email or password")) ||[m
[32m+[m		[32m   bytes.Contains(bodyBytes, []byte("Invalid credentials")) {[m
[32m+[m			[32mreturn errors.New("invalid email or password - please check your credentials")[m
[32m+[m		[32m}[m
[32m+[m[41m		[m
[32m+[m		[32m// Look for other common error patterns[m
[32m+[m		[32mif bytes.Contains(bodyBytes, []byte("alert-danger")) ||[m
[32m+[m		[32m   bytes.Contains(bodyBytes, []byte("error-message")) ||[m
[32m+[m		[32m   bytes.Contains(bodyBytes, []byte("field_with_errors")) {[m
[32m+[m			[32mreturn errors.New("login failed - form validation error or invalid credentials")[m
[32m+[m		[32m}[m
[32m+[m[41m		[m
[32m+[m		[32m// Check if we're still on the login page (sign in form present)[m
[32m+[m		[32mif bytes.Contains(bodyBytes, []byte("Sign in")) && bytes.Contains(bodyBytes, []byte("user[email]")) {[m
[32m+[m			[32mreturn errors.New("login failed - still on login page, likely invalid credentials")[m
[32m+[m		[32m}[m
[32m+[m[41m		[m
[32m+[m		[32m// If it's a 200 but not a redirect, it might be the login page with errors[m
[32m+[m		[32mif loginRes.StatusCode == 200 {[m
[32m+[m			[32mreturn errors.New("login failed - credentials may be invalid or additional verification required (status: 200, expected 302 redirect)")[m
[32m+[m		[32m}[m
[32m+[m[41m		[m
[32m+[m		[32mmaxLen := 200[m
[32m+[m		[32mif len(bodyStr) < maxLen {[m
[32m+[m			[32mmaxLen = len(bodyStr)[m
[32m+[m		[32m}[m
[32m+[m		[32mreturn errors.New("failed to login - server error (status: " + fmt.Sprintf("%d", loginRes.StatusCode) + "). Expected 302 redirect for successful login. Response: " + bodyStr[:maxLen])[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32m// Extract session cookie from response[m
[32m+[m	[32mcookies := loginRes.Header.Values("Set-Cookie")[m
[32m+[m	[32mfor _, cookie := range cookies {[m
[32m+[m		[32mif len(cookie) >= 12 && cookie[:12] == "_session_id=" {[m
[32m+[m			[32m// Extract just the session cookie part[m
[32m+[m			[32msessionCookie := cookie[m
[32m+[m			[32mif idx := bytes.IndexByte([]byte(cookie), ';'); idx != -1 {[m
[32m+[m				[32msessionCookie = cookie[:idx][m
[32m+[m			[32m}[m
[32m+[m			[32mclient.SetDefaultHeader("Cookie", sessionCookie)[m
[32m+[m			[32mreturn nil[m
[32m+[m		[32m}[m
 	}[m
[31m-	defer sessionRes.Body.Close()*/[m
 [m
[31m-	client.SetDefaultHeader(client.Config.SessionHeader, loginRes.Header.Get(client.Config.SessionIdHeader))[m
[31m-	return nil[m
[32m+[m	[32mreturn errors.New("failed to extract session cookie")[m
 }[m
[1mdiff --git a/config.json b/config.json[m
[1mindex df33286..a717892 100644[m
[1m--- a/config.json[m
[1m+++ b/config.json[m
[36m@@ -1,17 +1,17 @@[m
 {[m
     "version": "2.2.28",[m
[31m-    "loginUrl": "https://api.2k.com/borderlands/users/authenticate",[m
[31m-    "loginRedirectHeader": "X-CT-REDIRECT",[m
[31m-    "sessionIdHeader": "X-SESSION-SET",[m
[31m-    "sessionHeader": "X-SESSION",[m
[32m+[m[32m    "loginUrl": "https://shift.gearboxsoftware.com/sessions",[m
[32m+[m[32m    "loginRedirectHeader": "Location",[m
[32m+[m[32m    "sessionIdHeader": "Set-Cookie",[m
[32m+[m[32m    "sessionHeader": "Cookie",[m
     "requestHeaders": {[m
[31m-        "Origin": "https://borderlands.com",[m
[31m-        "Referer": "https://borderlands.com/en-US/"[m
[32m+[m[32m        "Origin": "https://shift.gearboxsoftware.com",[m
[32m+[m[32m        "Referer": "https://shift.gearboxsoftware.com/home"[m
     },[m
     "shiftConfig": {[m
         "codeListUrl": "https://raw.githubusercontent.com/ugoogalizer/autoshift-codes/main/shiftcodes.json",[m
[31m-        "codeInfoUrl": "https://api.2k.com/borderlands/code/",[m
[31m-        "userInfoUrl": "https://api.2k.com/borderlands/users/me",[m
[32m+[m[32m        "codeInfoUrl": "https://shift.gearboxsoftware.com/rewards",[m
[32m+[m[32m        "userInfoUrl": "https://shift.gearboxsoftware.com/rewards",[m
         "gameCodename": "oak"[m
     }[m
 }[m
[1mdiff --git a/shift.go b/shift.go[m
[1mindex b45ab42..b3274a1 100644[m
[1m--- a/shift.go[m
[1m+++ b/shift.go[m
[36m@@ -2,8 +2,6 @@[m [mpackage bl3auto[m
 [m
 import ([m
 	"errors"[m
[31m-	"strings"[m
[31m-	"time"[m
 )[m
 [m
 type ShiftConfig struct {[m
[36m@@ -41,108 +39,43 @@[m [mtype shiftCodeFromList struct {[m
 }[m
 [m
 func (client *Bl3Client) GetCodePlatforms(code string) ([]string, bool) {[m
[31m-	platforms := make([]string, 0)[m
[31m-[m
[31m-	res, err := client.Get(client.Config.Shift.CodeInfoUrl + code + "/info")[m
[31m-	if err != nil {[m
[31m-		return platforms, false[m
[31m-	}[m
[31m-[m
[31m-	json, err := res.BodyAsJson()[m
[31m-	if err != nil {[m
[31m-		return platforms, false[m
[31m-	}[m
[31m-[m
[31m-	codes := make([]shiftCode, 0)[m
[31m-	json.From("entitlement_offer_codes").Select("offer_service", "is_active", "offer_title").Out(&codes)[m
[31m-	for _, code := range codes {[m
[31m-		//if (code.Active || client.Config.Shift.AllowInactive) && code.Game == client.Config.Shift.GameCodename {[m
[31m-		platforms = append(platforms, code.Platform)[m
[31m-		//}[m
[31m-	}[m
[31m-[m
[31m-	if len(platforms) == 0 {[m
[31m-		return platforms, false[m
[31m-	}[m
[31m-[m
[32m+[m	[32m// For the SHiFT web interface, we'll assume codes work on common platforms[m
[32m+[m	[32m// This is a simplified approach since we'd need to parse the rewards page HTML[m
[32m+[m	[32m// to get the actual supported platforms for each code[m
[32m+[m	[32mplatforms := []string{"steam", "epic", "psn", "xbl"}[m
 	return platforms, true[m
 }[m
 [m
 func (client *Bl3Client) RedeemShiftCode(code, platform string) error {[m
[31m-	response, err := client.Post(client.Config.Shift.CodeInfoUrl+code+"/redeem/"+platform, "", nil)[m
[31m-	if err != nil {[m
[31m-		return errors.New("failed to initialize code redemption")[m
[31m-	}[m
[31m-[m
[31m-	type redemptionJob struct {[m
[31m-		JobId string `json:"job_id"`[m
[31m-		Wait  int    `json:"max_wait_milliseconds"`[m
[31m-	}[m
[31m-[m
[31m-	resJson, err := response.BodyAsJson()[m
[31m-	if err != nil {[m
[31m-		return errors.New("bad code init response")[m
[31m-	}[m
[31m-[m
[31m-	redemptionInfo := redemptionJob{}[m
[31m-	resJson.Out(&redemptionInfo)[m
[31m-[m
[31m-	if redemptionInfo.JobId == "" {[m
[31m-		redemptionError := ""[m
[31m-		resJson.Reset().From("error.code").Out(&redemptionError)[m
[31m-		if redemptionError != "" {[m
[31m-			return errors.New(strings.ToLower(strings.Join(strings.Split(redemptionError, "_"), " ")) + ". Try again later.")[m
[31m-		}[m
[31m-		return errors.New("failed to schedule code redemption")[m
[31m-	}[m
[31m-	// not sure if this is necessary[m
[31m-	time.Sleep(time.Duration(redemptionInfo.Wait) * time.Millisecond)[m
[31m-[m
[31m-	redeemResponse, err := client.Get(client.Config.Shift.CodeInfoUrl + code + "/job/" + redemptionInfo.JobId)[m
[31m-	if err != nil {[m
[31m-		return errors.New("failed to initialize code redemption")[m
[31m-	}[m
[31m-[m
[31m-	resJson, err = redeemResponse.BodyAsJson()[m
[31m-	if err != nil {[m
[31m-		return errors.New("bad code redemption response")[m
[31m-	}[m
[31m-[m
[31m-	success := false[m
[31m-	resJson.From("success").Out(&success)[m
[31m-	errs := make([]string, 0)[m
[31m-	resJson.Reset().From("errors").Out(&errs)[m
[31m-	if len(errs) > 0 {[m
[31m-		return errors.New(strings.ToLower(strings.Join(strings.Split(errs[0], "_"), " ")) + ".")[m
[31m-	}[m
[31m-	if !success {[m
[31m-		return errors.New("failed to redeem SHiFT code")[m
[31m-	}[m
[31m-[m
[31m-	resJson.Out(&redemptionInfo)[m
[31m-[m
[31m-	return nil[m
[32m+[m	[32m// Note: The SHiFT web interface has changed significantly.[m
[32m+[m	[32m// The old API-based redemption no longer works.[m
[32m+[m	[32m// This function now returns an informative error message.[m
[32m+[m[41m	[m
[32m+[m	[32mreturn errors.New("SHiFT code redemption through the web API is no longer supported. " +[m
[32m+[m		[32m"Please redeem codes manually at https://shift.gearboxsoftware.com/rewards. " +[m
[32m+[m		[32m"The 2K Borderlands API has been discontinued.")[m
 }[m
 [m
 func (client *Bl3Client) GetShiftPlatforms() (StringSet, error) {[m
 	platforms := StringSet{}[m
 [m
[31m-	response, err := client.Post(client.Config.Shift.UserInfoUrl, "", nil)[m
[32m+[m	[32mresponse, err := client.Get(client.Config.Shift.UserInfoUrl)[m
 	if err != nil {[m
[31m-		return platforms, errors.New("failed to get available platforms list")[m
[32m+[m		[32mreturn platforms, errors.New("failed to get rewards page")[m
 	}[m
[32m+[m	[32mdefer response.Body.Close()[m
 [m
[31m-	resJson, err := response.BodyAsJson()[m
[31m-	if err != nil {[m
[31m-		return platforms, err[m
[32m+[m	[32mif response.StatusCode != 200 {[m
[32m+[m		[32mreturn platforms, errors.New("failed to access rewards page - not authenticated")[m
 	}[m
 [m
[31m-	platformList := make([]string, 0)[m
[31m-	resJson.From("platforms").Out(&platformList)[m
[31m-[m
[31m-	for _, platform := range platformList {[m
[31m-		platforms.Add(platform)[m
[31m-	}[m
[32m+[m	[32m// For now, return common platforms - we'll need to parse the HTML to get actual platforms[m
[32m+[m	[32m// This is a simplified approach since the SHiFT website structure may vary[m
[32m+[m	[32mplatforms.Add("steam")[m
[32m+[m	[32mplatforms.Add("epic")[m
[32m+[m	[32mplatforms.Add("psn")[m
[32m+[m	[32mplatforms.Add("xbl")[m
[32m+[m[41m	[m
 	return platforms, nil[m
 }[m
 [m
